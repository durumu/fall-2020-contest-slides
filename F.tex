\section{F}%
\label{sec:f}

\begin{frame}
  \frametitle{Problem F: Garden Growth}

  \begin{itemize}
    \item First solve at 00:58 by \textbf{whatever} (Chinh Luu and Matthew Tran)
    \item Suppose a pot is initially empty. For a query from $a$ to $b$, we can prove by induction that the pot is empty if and only if there is
      an even number of friends in this range who try to put a plant in it.
    \item Consider the state of the pot, then, as a 0 or 1. We can notice that this property is exactly equivalent to the exclusive-or operation.
    \item \[ \underbrace{1 \oplus 1 \oplus \cdots \oplus 1}_{\text{even number of 1's}} = 0,\quad\text{and}\quad
      \underbrace{1 \oplus 1 \oplus \cdots \oplus 1}_{\text{odd number of 1's}} = 1. \]
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Problem F: Garden Growth (continued)}
  \begin{itemize}
      \item We can do this operation on a $k$-bit number, and represent the state of each pots as each of one of the $k$ bits
      \item The problem is reduced to quickly answering xor queries on an array $A$ 
      \item Exploit another property of xor: $x \oplus x = 0$ for all $x$
    \item We can precompute the cumulative xors
      from $A[0\dots i]$ for all $i$. Call that $C[i]$. Then the answer to a query is the number of bits set in the number \[ A[a...b] \oplus y = C[b] \oplus C[a-1] \oplus y, \]
      where $y$ is the initial state of the pots.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Problem F: C++ Solution}
  \cppf{F}
\end{frame}

\begin{frame}
  \frametitle{Problem F: C++ Solution (continued)}
  \cppf{F2}
\end{frame}

\begin{frame}
  \frametitle{Problem F: C++ Solution (continued)}
  \cppf{F3}
\end{frame}
